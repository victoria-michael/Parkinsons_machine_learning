# -*- coding: utf-8 -*-
"""Time_Series_test.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kCpg7A7YUMHKjQBY0b-vriELC6s6-fhE
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv("https://raw.githubusercontent.com/jbrownlee/Datasets/master/airline-passengers.csv")

df.head(10)

df['Month'] = pd.to_datetime(df['Month'])
#converts column to datetime

df.head()

df.set_index("Month", inplace=True)
plt.figure(figsize=(10,6))
plt.plot(df.index, df.Passengers, '--', marker='*', )
plt.grid()
plt.xlabel('Year')
plt.ylabel('Passengers')

#check for missing values
df.isnull().values.any()

#no empty values, so we improvise by creating a copy and making some rows null

df_copy = df.copy()
rows = df_copy.sample(frac=0.1, random_state=0)
rows['Passengers'] = np.nan
df_copy.loc[rows.index, 'Passengers'] = rows['Passengers']
df_copy.isnull().sum()
#we have 14 null values in the dataset now

#filling missing data by imputation -- forward fill
df_copy_ffill = df_copy.fillna(method='ffill')
df_copy_ffill.isnull().sum()

#filling missing data by imputation -- backward fill
df_copy_bfill = df_copy.fillna(method='bfill')
df_copy_bfill.isnull().sum()

#filling missing data by interpolation
df_copy_LIF = df_copy.interpolate(method='linear', limit_direction='forward')
df_copy_LIF.isnull().sum()

#filling missing data by interpolation
df_copy_LIB = df_copy.interpolate(method='linear', limit_direction='backward')
df_copy_LIB.isnull().sum()

"""***Downsampling and Upsampling***"""

#downsample to quarterly data points
df_quarterly = df.resample('3M').mean()

#upsample to quarterly data points
df_daily = df.resample('D').mean()

df_MA = df.copy()
MA = df_MA['Passengers'].rolling(12).mean()

"""***Time Series Specific Exploratory Methods***"""

import statsmodels.api as sm
from pylab import rcParams
rcParams['figure.figsize'] = 15,8
decompose_series = sm.tsa.seasonal_decompose(df['Passengers'], model='additive')
decompose_series.plot()
plt.show()

"""*The decomposed series shows an obvious increasing trend and seasonality variation. Recall that we have initially plotted the moving average on the last 12 months which showed that it varies with time. This suggests that the data is not stationary. We will now perform an ADF test to confirm this speculation*"""

from statsmodels.tsa.stattools import adfuller
adf_result = adfuller(df['Passengers'])
print(f'ADF Statistic: {adf_result[0]}')
print(f'p-value: {adf_result[1]}')
print(f'No of lags used : {adf_result[2]}')
print(f'No of observations used: {adf_result[3]}')
print('Critical Values: ')

for k,v in adf_result[4].items():
  print(f'  {k}: {v}')

"""*From the results obtained, the p-value is greater than the critical value at a 5% significance level and, the ADF statistic is greater that any of the critical values obtained. This confirms that the series is indeed non-stationary.*"""

#Convert time series to stationary by removing trend and seasonality

#Transformation and Differencing

df_log = np.log(df)
df_diff = df_log.diff(periods= 1 )
plt.plot(df_diff.index, df_diff.Passengers, '-' )
plt.plot(df_diff.rolling( 12 ).mean(), color= 'red' )

from statsmodels.tsa.stattools import acf, pacf
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

#ACF
plot_acf(df_diff, lags = range(0, 20))
plt.show()

#PACF
plot_pacf(df_diff, lags = range(0, 20))
plt.show()

"""The shaded regions in the plots are the confidence intervals. The lags where the PACF and ACF charts cross this region are the values for p and q respectively. In both plots, *p=q=1*.

The shaded regions in the plots are the confidence intervals. The lags where the PACF and ACF charts cross this region are the values for p and q respectively.

In the ACF plot, there is one lag that crosses the significance level hence, *q=1*. Similarly, in the PACF plot, *p=2*
"""

#AR, MA, ARIMA

from statsmodels.tsa.arima_model import ARIMA
#(p,d,q)
AR_Model = ARIMA(df_diff, order=(2,0,0))
AR_Model_Results = AR_Model.fit()
plt.plot(df_diff)
plt.plot(AR_Model_Results.fittedvalues, color='red')